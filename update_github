#!/usr/local/bin/ruby
load 'script/github.rb'
require 'yaml'
require 'time'

def help
  puts <<EOS
#{$0} create <files> - sends each of <files> to Github and writes index to gists.yml
#{$0} update <files> - like create, but ignores files already in gists.yml if file hasn't changed since last time this script was run
#{$0} diff <files> - like update, but shows which of <files> would be updated without actually doing anything
EOS
  exit 1
end

private

def init
  $GISTSFILE = ENV['GISTS_FILE_NAME'] || 'gists.yml'
  raise "Can't stat #{$GISTSFILE}" unless File.writable?($GISTSFILE)
  $GISTS = YAML.load_file $GISTSFILE
  $GH =  Github.new()
end

def write_gist_file(gists)
  File.open($GISTSFILE, 'w') do |f|
    f.write <<EOS
# This file is automatically generated by #{$0}.  Don't modify it!
# If you've changed or added a codefile, run '#{$0} update' instead.
EOS
    f.write $GISTS.to_yaml
  end
end

def truncate_gist_file
  write_gist_file(Hash.new)
end

def get_files_to_update
  allfiles = ARGV.length
  # a file can be skipped if its filename already appears in paste list
  # AND its modtime is no older than the last time this script ran.
  files = ARGV.reject do |filename|
    $GISTS.has_key?(filename) &&
      File.stat(filename).mtime <= $GISTS[filename]['updated_at']
  end
  return [files, allfiles]
end

public

def create
  $GISTS = {}
  nfiles = ARGV.length
  ok = 0
  ARGV.each do |filename|
    if (resp = $GH.paste_file(filename))
      $GISTS[filename] = {
        'url' => resp.gsub(%r{^.*/}, ''),
        'updated_at' => Time.now
      }
      ok += 1
    end
  end
  write_gist_file($GISTS)
  puts "#{ok} out of #{nfiles} pasted, index is #{$GISTSFILE}"
end

def update
  files, numfiles = get_files_to_update
  puts "Updating #{files.length} out of #{numfiles} files..."
  ok = 0
  files.each do |filename|
    if (resp = $GH.paste_file(filename))
      $GISTS[filename] = {
        'url' => resp.gsub(%r{^.*/}, ''),
        'updated_at' => Time.now
      }
      ok += 1
    end
  end
  write_gist_file($GISTS)
  puts "#{ok} out of #{files.length} pasted  (#{numfiles-files.length} already in index)"
end

def delete
  ok = 0
  orig_length = $GISTS.keys.length
  $GISTS.each_pair do |k,v|
    if $GH.delete(v['url'])
      ok += 1
      $GISTS.delete(k)
    end
  end
  write_gist_file($GISTS)
  puts "#{ok} out of #{orig_length} deleted"
end

def diff
  files,numfiles = get_files_to_update
  puts files.join("\n")
  puts "\n#{files.length} out of #{numfiles} files would be updated"
end

help unless ARGV.length >= 1
init()
cmd = ARGV.shift
begin
  self.send cmd
rescue Exception => e
  puts "Failed: #{e.message} #{e.backtrace}"
  exit false
end

