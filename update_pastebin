#!/usr/bin/ruby
load 'script/pastebin.rb'
require 'yaml'
require 'time'

def help
  puts <<EOS
#{$0} create <files> - sends each of <files> to Pastebin and writes index to pasties.yml
#{$0} update <files> - like create, but ignores files already in pasties.yml if file hasn't changed since last time this script was run
#{$0} diff <files> - like update, but shows which of <files> would be updated without actually doing anything
#{$0} delete - deletes all pasties listed in pasties.yml
#{$0} delete_all - deletes all our pasties, period - the nuclear option - don't use!
EOS
  exit 1
end

private

def init
  $PASTIEFILE = ENV['PASTIE_FILE_NAME'] || 'pasties.yml'
  raise "Can't stat #{$PASTIEFILE}" unless File.writable?($PASTIEFILE)
  $PASTIES = YAML.load_file $PASTIEFILE
  $PB =  Pastebin.new(
  :api_dev_key => ENV['PASTEBIN_API_KEY'],
  :api_user_name => ENV['PASTEBIN_USERNAME'],
  :api_user_password => ENV['PASTEBIN_PASSWORD']
    )
end

def write_pastie_file(pasties)
  File.open($PASTIEFILE, 'w') do |f|
    f.write <<EOS
# This file is automatically generated by #{$0}.  Don't modify it!
# If you've changed or added a codefile, run '#{$0} update' instead.
EOS
    f.write $PASTIES.to_yaml
  end
end

def truncate_pastie_file
  write_pastie_file(Hash.new)
end

def get_files_to_update
  allfiles = ARGV.length
  # a file can be skipped if its filename already appears in paste list
  # AND its modtime is no older than the last time this script ran.
  files = ARGV.reject do |filename|
    $PASTIES.has_key?(filename) &&
      File.stat(filename).mtime <= $PASTIES[filename]['updated_at']
  end
  return [files, allfiles]
end

public

def create
  $PASTIES = {}
  nfiles = ARGV.length
  ok = 0
  ARGV.each do |filename|
    if (resp = $PB.paste_file(filename))
      $PASTIES[filename] = {
        'url' => resp.gsub(%r{^.*/}, ''),
        'updated_at' => Time.now
      }
      ok += 1
    end
  end
  write_pastie_file($PASTIES)
  puts "#{ok} out of #{nfiles} pasted, index is #{$PASTIEFILE}"
end

def update
  files, numfiles = get_files_to_update
  puts "Updating #{files.length} out of #{numfiles} files..."
  ok = 0
  files.each do |filename|
    if (resp = $PB.paste_file(filename))
      $PASTIES[filename] = {
        'url' => resp.gsub(%r{^.*/}, ''),
        'updated_at' => Time.now
      }
      ok += 1
    end
  end
  write_pastie_file($PASTIES)
  puts "#{ok} out of #{files.length} pasted  (#{numfiles-files.length} already in index)"
end

def delete
  ok = 0
  orig_length = $PASTIES.keys.length
  $PASTIES.each_pair do |k,v|
    if $PB.delete(v['url'])
      ok += 1
      $PASTIES.delete(k)
    end
  end
  write_pastie_file($PASTIES)
  puts "#{ok} out of #{orig_length} deleted"
end

def diff
  files,numfiles = get_files_to_update
  puts files.join("\n")
  puts "\n#{files.length} out of #{numfiles} files would be updated"
end

help unless ARGV.length >= 1
init()
cmd = ARGV.shift
begin
  self.send cmd
rescue Exception => e
  puts "Failed: #{e.message} #{e.backtrace}"
  exit false
end

